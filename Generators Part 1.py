# Функция simple_sequence()
# Реализуйте генераторную функцию simple_sequence(), которая не принимает никаких
# аргументов.

# Функция должна возвращать генератор, порождающий бесконечную возрастающую
# последовательность натуральных чисел, в которой каждое число встречается столько
# раз, каково оно:
# 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, ..

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию simple_sequence(), но не код, вызывающий ее.

def simple_sequence():
    value = 1
    while True:
        for _ in range(value):
            yield value
        value += 1



# Функция alternating_sequence()
# Реализуйте генераторную функцию alternating_sequence(), которая принимает один
# аргумент:

# count — натуральное число, по умолчанию имеет значение None

# Если count имеет значение None, функция должна возвращать генератор, порождающий
# бесконечный знакочередующийся ряд натуральных чисел.

# Если count имеет в качестве значения натуральное число, функция должна возвращать
# генератор, порождающий первые count чисел знакочередующегося ряда натуральных чисел,
# а затем возбуждающий исключение StopIteration.

# Примечание 1. Знакочередующийся ряд натуральных чисел имеет вид:
# 1, -2, 3, -4, 5, -6, 7, -8, 9, -10, ...

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную  функцию alternating_sequence(), но не код, вызывающий ее.

def alternating_sequence(count=None):
    value = 0
    while not count == value:
        value += 1
        yield [-value, value][value % 2]



# Функция primes()
# Реализуйте генераторную функцию primes(), которая принимает два аргумента в следующем
# порядке:

# eft — натуральное число
# right — натуральное число

# ункция должна возвращать генератор, порождающий последовательность простых чисел от
# left до right включительно, а затем возбуждающий исключение StopIteration.

# римечание 1. Гарантируется, что left <= right.

# Примечание 2. Простое число — натуральное число, имеющее ровно два различных натуральных
# делителя — единицу и самого себя. Единица простым числом не является. 

# Примечание 3. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию primes(), но не код, вызывающий ее.

def primes(left, right):
    count = 0
    divider = 2
    while left != right+1:
        if left != 1:
            while divider < left:
                if left % divider == 0:
                    count += 1
                divider += 1
            if count == 0:
                divider = 2
                yield left
                left += 1
            else:
                divider = 2
                count = 0
                left += 1
        else:
            left += 1



# Функция reverse()
# Реализуйте генераторную функцию reverse(), которая принимает один аргумент:

# sequence — последовательность

# Функция должна возвращать генератор, порождающий элементы последовательности
# sequence в обратном порядке, а затем возбуждающий исключение StopIteration.

# Примечание 1. Последовательностью является коллекция, поддерживающая индексацию
# и имеющая длину. Например, объекты типа list, str, tuple являются последовательностями.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию reverse(), но не код, вызывающий ее.

def reverse(sequence):
    try:
        for i in sequence[::-1]:
            yield i
    except StopIteration:
        raise



# Функция dates()
# Реализуйте генераторную функцию dates(), которая принимает два аргумента в следующем
# порядке:

# start — дата, тип date
# count — натуральное число, по умолчанию имеет значение None

# Если count имеет значение None, функция должна возвращать генератор, порождающий
# последовательность из максимально допустимого количества дат (тип date), начиная с даты
# start.

# Если count имеет в качестве значения натуральное число, функция должна возвращать
# генератор, порождающий последовательность из count дат (тип date), начиная с даты start,
# а затем возбуждающий исключение StopIteration.

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию dates(), но не код, вызывающий ее.

from datetime import timedelta, date


def dates(start, count=None):
    counter = 0
    while not count == counter:
        counter += 1
        yield start
        if start != date(9999, 12, 30):
            start += timedelta(hours=24)
        else:
            yield date(9999, 12, 31)
            break



# Функция card_deck()
# Реализуйте генераторную функцию card_deck(), которая принимает один аргумент:

# suit — одна из четырех карточных мастей: пик, треф, бубен, червей

# Функция должна возвращать генератор, циклично порождающий колоду игральных карт без
# масти suit. Каждая карта должна представлять собой строку в следующем формате:

# <номинал> <масть>

# Например, 7 пик, валет треф, дама бубен, король червей, туз пик.

# Примечание 1. Карты, генерируемые итератором, должны располагаться сначала по величине
# номинала, затем масти.

# Примечание 2. Старшинство мастей по возрастанию: пики, трефы, бубны, червы. Старшинство
# карт в масти по возрастанию: двойка, тройка, четверка, пятерка, шестерка, семерка,
# восьмерка, девятка, десятка, валет, дама, король, туз.

# Примечание 3. Масти не требуют склонения и независимо от номинала должны сохранять
# следующее написание: пик, треф, бубен, червей.

# Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию card_deck(), но не код, вызывающий ее.

def card_deck(suit):
    suits = ["пик", "треф", "бубен", "червей"]
    card_values = ("2", "3", "4", "5", "6", "7", "8", "9", "10", "валет", "дама", "король", "туз")
    suits.remove(suit)
    while True:
        for st in suits:
            for value in card_values:
                yield f'{value} {st}'



# Функция matrix_by_elem()
# Вам доступна генераторная функция matrix_by_elem(), которая принимает в качествеаргумента
# матрицу произвольной размерности и возвращает генератор, порождающий последовательность
# элементов переданной матрицы.

# Перепишете данную функцию с использованием конструкции yield from, чтобы она выполняла
# ту же задачу.

# Примечание 1. Под матрицей подразумеваются исключительно вложенные списки.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию matrix_by_elem(), но не код, вызывающий ее.

def matrix_by_elem(matrix):
    for row in matrix:
        yield from row



# Функция palindromes()
# Реализуйте генераторную функцию palindromes(), которая не принимает никаких аргументов.

# Функция должна возвращать генератор, порождающий бесконечную последовательность натуральных
# чисел-палиндромов.

# Примечание 1. Число-палиндром — число, которое читается одинаково как справа налево,
# так и слева направо.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию palindromes(), но не код, вызывающий ее.

def palindromes():
    number = 1
    while True:
        if str(number) == str(number)[::-1]:
            yield number
            number += 1
        number += 1



# Функция flatten() 🌶️🌶️
# Реализуйте генераторную функцию flatten(), которая принимает один аргумент:

# nested_list — список, элементами которого являются целые числа или списки, элементами
# которых, в свою очередь, также являются либо целые числа, либо списки; вложенность может
# быть произвольной

# Функция должна возвращать генератор, порождающий все числа, содержащиеся в nested_list,
# включая все числа из всех вложенных списков, а затем возбуждает исключение StopIteration.

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# генераторную функцию flatten(), но не код, вызывающий ее.

def flatten(nested_list):
    for item in nested_list:
        if isinstance(item, list):
            yield from flatten(item)
        else:
            yield item