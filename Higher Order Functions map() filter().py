# Вам доступен список data, содержащий произвольные объекты. Дополните приведенный
# ниже код, чтобы он вывел все числа (тип int и float), находящиеся в данном списке,
# отбрасывая дробную часть у вещественных чисел. Числа должны быть расположены в
# своем исходном порядке, каждое на отдельной строке.

# Примечание 1. Начальная часть ответа выглядит так:

# -16
# -202
# 883
# ...

from math import trunc


data = ['Timur', -16.648911695768902, 'six', -202, 883.0093275936454, -765, (3, 4),
        -105.10718000213546, 976, -308.96857946288094, 458, ['one', 'two'], 479.92207220345927,
        -87, -71, 'twelve', 112, -621, -715.0179551194733, 'seven', 229, 729, -358, [1, 2, 3],
        -974, 882, -894.4709033242768, '', 323.7720806756133, 'beegeek', -224, 431, 170.6353248658936,
        -343.0016746052049, 'number', 104.17133679352878, [], -353.5964777099863, 'zero', -113, 288,
        None, -708.3036176571618]

int_float_from_data = list(filter(lambda x: isinstance(x, int | float), data))
print(*list(map(lambda x: trunc(x) if isinstance(x, float) else x, int_float_from_data)), sep='\n')



# Вам доступен список names, содержащий имена на русском языке. Дополните приведенный
# ниже код, чтобы он вывел все имена, которые начинаются на буквы А и М (независимо
# от регистра) и имеют длину больше 4. Имена должны быть расположены в лексикографическом
# порядке, через пробел, каждое с заглавной буквы.

# Примечание 1. Начальная часть ответа выглядит так:

# Аделина Айлин Александр ...

names = ['ульяна', 'арина', 'Дмитрий', 'Сергей', 'Яна', 'мила', 'Ольга', 'софья', 'семён', 'Никита',
         'маргарита', 'Василиса', 'Кирилл', 'александр', 'александра', 'Иван', 'андрей', 'Родион',
         'максим', 'алиса', 'Артём', 'софия', 'владимир', 'дамир', 'Валерий', 'степан', 'Алексей',
         'Марк', 'олег', 'ирина', 'Милана', 'мия', 'денис', 'Фёдор', 'Елизавета', 'айлин', 'Варвара',
         'валерия', 'Алёна', 'Николь', 'юлия', 'Ксения', 'пётр', 'георгий', 'Мария', 'глеб', 'илья',
         'Захар', 'Дарья', 'Евгения', 'матвей', 'Серафим', 'екатерина', 'Тимофей', 'виктор', 'Егор',
         'Ника', 'анна', 'даниил', 'тихон', 'вера', 'кира', 'Эмилия', 'Виктория', 'Игорь', 'полина',
         'алина', 'Давид', 'анастасия', 'Вероника', 'ярослав', 'Руслан', 'татьяна', 'Демид', 'амелия',
         'Элина', 'Арсен', 'евгений', 'мадина', 'дарина', 'Савелий', 'Платон', 'Аделина', 'диана',
         'Айша', 'павел', 'Стефания', 'Тимур', 'Ева', 'Елисей', 'Артемий', 'григорий', 'Мирон',
         'Мирослава', 'Мира', 'Марат', 'Лилия', 'роман', 'владислав', 'Леонид']

filtered_names = list(filter(lambda name: name[0].lower() in 'ам' and len(name) > 4, names))
print(*sorted(map(lambda name: name.capitalize(), filtered_names)))



# Функция fib()
# Используя синтаксис анонимных функций, реализуйте рекурсивную функцию fib(), которая
# принимает один аргумент:

# n — натуральное число

# Функция должна возвращать n-ый член последовательности Фибоначчи.

# Примечание 1. Последовательность Фибоначчи – последовательность натуральных чисел,
# где каждое последующее число является суммой двух предыдущих: 
# 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ...

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию fib(), но не код, вызывающий ее.

fib = lambda x: 1 if x <= 2 else fib(x-1) + fib(x-2)



# Функция print_operation_table()
# Реализуйте функцию print_operation_table(), которая принимает три аргумента в следующем
# порядке:

# operation — функция, характеризующая некоторую бинарную операцию
# rows — натуральное число
# cols — натуральное число

# Функция должна составлять и выводить таблицу из rows строк и cols столбцов, в которой
# элемент со строкой nn и столбцом mm имеет значение operation(n, m).

# Примечание 1. Нумерация строк и столбцов в таблице начинается с единицы.

# Примечание 2. Элементы в строках таблицы должны быть разделены одним пробелом, причем
# выравнивать таблицу необязательно.

# Примечание 3. Бинарная операция — математическая операция, принимающая два аргумента
# и возвращающая один результат.

# Примечание 4. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию print_operation_table(), но не код, вызывающий ее.

def print_operation_table(operation, rows, cols):
    
    result_table = ''
    temp = ''
    
    for i in range(1, cols+1):
        for j in range(1, rows+1):
            temp += f'{str(operation(i, j))} '
        result_table += f'{temp}\n'
        temp = ''
    
    return result_table



# # Функция verification()
# Реализуйте функцию verification(), которая проверяет правильность введенного
# пароля. Она должна принимать четыре аргумента в следующем порядке:

# login — логин пользователя
# password — пароль пользователя
# success — некоторая функция
# failure — некоторая функция

# Пароль считается правильным, если в нем присутствует, хотя бы одна заглавная
# латинская буква, хотя бы одна строчная латинская буква и хотя бы одна цифра.
# Функция verification() должна вызывать функцию success() с аргументом login,
# если переданный пароль является правильным, иначе — функцию failure() с
# аргументами login и строкой-сообщением об ошибке:

# в пароле нет ни одной буквы, если в пароле отсутствуют латинские буквы
# в пароле нет ни одной заглавной буквы, если в пароле отсутствуют заглавные
# латинские буквы
# в пароле нет ни одной строчной буквы, если в пароле отсутствуют строчные
# латинские буквы
# в пароле нет ни одной цифры, если в пароле отсутствуют цифры

# Примечание 1. Если пароль не удовлетворяет нескольким условиям, то приоритеты
# выбора строки-сообщения об ошибке являются следующими:

# в пароле нет ни одной буквы
# в пароле нет ни одной заглавной буквы
# в пароле нет ни одной строчной буквы
# в пароле нет ни одной цифры

# Примечание 2. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию verification(), но не код, вызывающий ее.

import string


def verification(login, password, success, failure):
    if not any(char in string.ascii_letters for char in password):
        return failure(login, 'в пароле нет ни одной буквы')
    if not any(char in string.ascii_uppercase for char in password):
        return failure(login, 'в пароле нет ни одной заглавной буквы')
    if not any(char in string.ascii_lowercase for char in password):
        return failure(login, 'в пароле нет ни одной строчной буквы')
    if not any(char.isdigit() for char in password):
        return failure(login, 'в пароле нет ни одной цифры')
    else:
        return success(login)


def success(login):
    print(f'Здравствуйте, {login}!')


def failure(login, text):
    print(f'{login}, попробуйте снова. Текст ошибки: {text}')


verification('Arthur_Davletov', 'мойпароль123', success, failure)
