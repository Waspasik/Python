# Зоопарк
# Вам доступен файл zoo.json, содержащий список JSON-объектов с данными об обитателях
# некоторого зоопарка. Ключом в каждом объекте является название животного, значением
# — их количество в зоопарке:

# [
#    {
#       "Axolotl": 11,
#       "Poison Frog": 12,
#       "Sonoran Toad": 6,
#       "Tiger Salamander": 16
#    },
#    {
#       "African Fish Eagle": 6,
#       "Andean Condor": 8,
#       "Black Vulture": 8,
#       "Bufflehead Duck": 9,
#       "Flamingo": 8,
#       "Great Horned Owl": 16,
#       "Hornbill": 1
#    },
#    ...
# ]

# Напишите программу, которая определяет, сколько всего животных обитает в зоопарке,
# и выводит полученный результат.

# Примечание 1. Гарантируется, что все ключи в JSON-объектах, различны.

# Решение через Counter

import json
from collections import Counter

with open('zoo.json', 'r', encoding='utf-8') as file:
    print(sum([Counter(dct).total() for dct in json.load(file)]))

# Решение через ChainMap

import json
from collections import ChainMap

with open('zoo.json', 'r', encoding='utf-8') as file:
    print(sum(ChainMap(*json.load(file)).values()))



# Булочный магнат
# После ухода сети Макдональдс из России Тимур решил открыть свою небольшую бургерную.
# Цена каждого бургера в его ресторане определяется количеством ингредиентов, которые
# выбирает сам посетитель. Вам доступны словари, в которых в качестве ключа указано
# название ингредиента, а в качестве значения — его цена. Все ингредиенты разбиты по
# категориям, например, овощи содержатся
# в одном словаре, соусы — в другом.

# Напишите программу, которая принимает на вход ингредиенты, выбранные посетителем,
# и определяет их общую стоимость.

# Формат входных данных
# На вход программе подается последовательность ингредиентов, разделенных запятой
# без пробелов.

# Формат выходных данных
# Программа должна определить общую стоимость введенных ингредиентов и вывести
# полученный результат в виде чека, в котором указаны ингредиенты в лексикографическом
# порядке, количество каждых и их общая стоимость, в следующем формате:

# <ингредиент 1> x <количество 1>
# <ингредиент 2> x <количество 2>
# ...
# -------------------------------
# ИТОГ: <общая стоимость>р

# Примечание 1. Программа должна добавлять нужное количество пробелов, если один
# ингредиент имеет меньшую длину, чем другие.

# Примечание 2. Длина пунктирной линии должна равняться длине самой длинной строки
# в чеке, включая строку с итоговой стоимостью.

# Примечание 3. Гарантируется, что все ингредиенты, выбранные посетителем, присутствуют
# в словарях.

from collections import ChainMap, Counter      

bread = {'булочка с кунжутом': 15, 'обычная булочка': 10, 'ржаная булочка': 15}
meat = {'куриный бифштекс': 50, 'говяжий бифштекс': 70, 'рыбный бифштекс': 40}
sauce = {'сливочно-чесночный': 15, 'кетчуп': 10, 'горчица': 10, 'барбекю': 15, 'чили': 15}
vegetables = {'лук': 10, 'салат': 15, 'помидор': 15, 'огурцы': 10}
toppings = {'сыр': 25, 'яйцо': 15, 'бекон': 30}

cost_ingredients = ChainMap(bread, meat, sauce, vegetables, toppings)
customer_ingredients = Counter(input().split(','))
sorted_ingredients = sorted(customer_ingredients)
total_cost_burger = 0
result_check = []

for ingredient in sorted_ingredients:
    total_cost_burger += cost_ingredients[ingredient] * customer_ingredients[ingredient]
    result_check.append(f'{ingredient.ljust(len(max(sorted_ingredients, key=len)))} x {customer_ingredients[ingredient]}')

result_check.append(f'ИТОГ: {total_cost_burger}р')

print(*result_check[:-1], sep='\n')
print('-' * len(max(result_check, key=len)))
print(result_check[-1])