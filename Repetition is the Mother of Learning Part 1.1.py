# Функция hide_card()
# Реализуйте функцию hide_card(), которая принимает один аргумент:

# card_number — строка, представляющая собой корректный номер банковской карты
# из 16 цифр, между которыми могут присутствовать символы пробела
# Функция должна заменять первые 12 цифр в строке card_number на символ * и
# возвращать полученный результат. Если между цифрами в номере имелись символы
# пробела, их следует удалить.

# Примечание 1. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию hide_card(), но не код, вызывающий ее.

def hide_card(card_number):
    card_number = card_number.replace(' ', '')
    return ('*' * 12) + card_number[12:]



# Функция same_parity()
# Реализуйте функцию same_parity(), которая принимает один аргумент:

# numbers — список целых чисел

# Функция должна возвращать новый список, элементами которого являются числа
# из списка numbers, имеющие ту же четность, что и первый элемент этого списка.

# Примечание 1. Числа в возвращаемом функцией списке должны располагаться в
# своем исходном порядке. 

# Примечание 2. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию same_parity(), но не код, вызывающий ее.

def same_parity(numbers):
    return list(filter(lambda num: num % 2 == numbers[0] % 2, numbers))



# Функция is_valid()
# Будем считать, что PIN-код является корректным, если он удовлетворяет
# следующим условиям:

# состоит из 4, 5 или 6 символов
# состоит только из цифр (0−9)
# не содержит пробелов

# Реализуйте функцию is_valid(), которая принимает один аргумент:
# string — произвольная строка

# Функция должна возвращать значение True, если строка string представляет
# собой корректный PIN-код, или False в противном случае.

# Примечание 1. Если в функцию передается пустая строка, функция должна
# возвращать значение False.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию is_valid(), но не код, вызывающий ее.

def is_valid(string):
    return string.isdigit() and 4 <= len(string) <= 6



# Функция print_given()
# Реализуйте функцию print_given(), которая принимает произвольное количество
# позиционных и именованных аргументов и выводит все переданные аргументы,
# указывая тип каждого. Пары аргумент-тип должны выводиться каждая на отдельной
# строке, в следующем формате:

# для позиционных аргументов:
# <значение аргумента> <тип аргумента>

# для именованных аргументов:
 #<имя переменной> <значение аргумента> <тип аргумента>

# Примечание 1. При выводе позиционные аргументы должны быть расположены в
# порядке их передачи, именованные — в лексикографическом порядке имен переменных.

# Примечание 2. При выводе сначала должны следовать все позиционные аргументы,
# затем — все именованные.

# Примечание 3. Если в функцию ничего не передается, функция ничего не должна
# выводить.

# Примечание 4. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию print_given(), но не код, вызывающий ее.

def print_given(*args, **kwargs):
    for item in args:
        print(item, type(item))
    
    sorted_kwargs = dict(sorted(kwargs.items(), key=lambda item: item[0]))

    for key, value in sorted_kwargs.items():
        print(key, value, type(value))



# Функция convert()
# Реализуйте функцию convert(), которая принимает один аргумент:
# string — произвольная строка

# Функция должна возвращать строку string:
# полностью в нижнем регистре, если букв в нижнем регистре в этой строке
# больше
# полностью в верхнем регистре, если букв в верхнем регистре в этой строке
# больше
# полностью в нижнем регистре, если количество букв в верхнем и нижнем
# регистрах в этой строке совпадает

# Примечание 1. Символы строки, не являющиеся буквами, следует игнорировать.

# Примечание 2. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию convert(), но не код, вызывающий ее.

from functools import reduce

def convert(string):
    counter_up = reduce(lambda count, char: count + char.isupper(), string, 0)
    counter_low = reduce(lambda count, char: count + char.islower(), string, 0)

    if counter_low >= counter_up:
        return string.lower()
    else:
        return string.upper()



# Анаграммы — это слова, которые состоят из одинаковых букв. Например:
# адаптер — петарда
# адресочек — середочка
# азбука — базука
# аистенок — осетинка

# Реализуйте функцию filter_anagrams(), которая принимает два аргумента в
# следующем порядке:
# word — слово в нижнем регистре
# words — список слов в нижнем регистре

# Функция должна возвращать список, элементами которого являются слова из
# списка words, которые представляют анаграмму слова word. Если список words
# пуст или не содержит анаграмм, функция должна вернуть пустой список.

# Примечание 1. Слова в возвращаемом функцией списке должны располагаться в
# своем исходном порядке. 

# Примечание 2. Считайте, что слово является анаграммой самого себя.

# Примечание 3. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию filter_anagrams(), но не код, вызывающий ее.

def filter_anagrams(word, words):
    return list(filter(lambda w: sorted(w) == sorted(word), words))



# В различных социальных сетях существуют системы лайков, которые в зависимости
# от количества людей, оценивших запись, показывают соответствующую информацию.

# Реализуйте функцию likes(), которая принимает один аргумент:
# names — список имён

# Функция должна возвращать строку в соответствии с примерами ниже, содержание
# которой зависит от количества имён в списке names.

# Приведенный ниже код:
# print(likes([]))
# print(likes(['Тимур']))
# print(likes(['Тимур', 'Артур']))
# rint(likes(['Тимур', 'Артур', 'Руслан']))
# print(likes(['Тимур', 'Артур', 'Руслан', 'Анри']))
# print(likes(['Тимур', 'Артур', 'Руслан', 'Анри', 'Дима']))
# print(likes(['Тимур', 'Артур', 'Руслан', 'Анри', 'Дима', 'Рома', 'Гвидо', 'Марк']))

# должен выводить:
# Никто не оценил данную запись
# Тимур оценил(а) данную запись
# Тимур и Артур оценили данную запись
# Тимур, Артур и Руслан оценили данную запись
# Тимур, Артур и 2 других оценили данную запись
# Тимур, Артур и 3 других оценили данную запись
# Тимур, Артур и 6 других оценили данную запись

# Примечание 1. Имена в формируемой и возвращаемой функцией строке должны
# располагаться в своем исходном порядке.

# Примечание 2. Обратите внимание, что если в передаваемом в функцию списке
# более трех имен, то явно указываются лишь первые два из них. 

# Примечание 3. В тестирующую систему сдайте программу, содержащую только
# необходимую функцию likes(), но не код, вызывающий ее.

from functools import reduce

def likes(names):
    if bool(names):
        result = reduce(lambda string, name: string + ', ' + name, names[1:2], names[0])
        if len(names) > 3:
            return f'{result} и {len(names[2:])} других оценили данную запись'
        elif len(names) == 3:
            return f'{result} и {names[-1]} оценили данную запись'
        elif len(names) == 2:
            return f'{names[0]} и {names[1]} оценили данную запись'
        elif len(names) == 1:
            return f'{result} оценил(а) данную запись'
        else:
            return f'{result} оценили данную запись'
    
    return 'Никто не оценил данную запись'