# Строчный алфавит
# Напишите программу, которая выводит все строчные латинские буквы.

# Формат входных данных
# На вход программе ничего не подается.

# Формат выходных данных
# Программа должна вывести все строчные латинские буквы от a до z, каждую на отдельной
# строке.

for i in range(97, 123):
    print(chr(i))



# Функция convert()
# Реализуйте функцию convert(), которая принимает один аргумент:

# number — целое число

# Функция должна возвращать кортеж из трех элементов, расположенных в следующем порядке:

# двоичное представление числа number в виде строки без префикса 0b
# восьмеричное представление числа number в виде строки без префикса 0o
# шестнадцатеричное представление числа number в виде строки в верхнем регистре без
# префикса 0x

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию convert(), но не код, вызывающий ее.

def convert(number):
    return (bin(number).replace('0b', ''), oct(number).replace('0o', ''), f'{number:X}')



# Вам доступен словарь films, ключом в котором является название некоторого фильма, а
# значением — словарь с оценками этого фильма от изданий imdb и kinopoisk.

# Дополните приведенный ниже код, чтобы он вывел название фильма с наименьшей средней
# оценкой.

# Примечание 1. Гарантируется, что искомый фильм единственный.

# Примечание 2. Средней оценкой считается отношение суммы всех оценок к их количеству.

films = {'Spider-Man: No Way Home': {'imdb': 8.8, 'kinopoisk': 8.3},
         'Don"t Look Up': {'imdb': 7.3, 'kinopoisk': 7.6},
         'Encanto': {'imdb': 7.3, 'kinopoisk': 7.4},
         'The Witcher': {'imdb': 8.2, 'kinopoisk': 7.3},
         'Ghostbusters: Afterlife': {'imdb': 7.3, 'kinopoisk': 8},
         'Harry Potter 20th Anniversary: Return to Hogwarts': {'imdb': 8.1, 'kinopoisk': 8.2},
         'Shingeki no Kyojin': {'imdb': 9.0, 'kinopoisk': 8.3},
         'The Matrix': {'imdb': 8.7, 'kinopoisk': 8.5},
         'The Dark Knight': {'imdb': 9.0, 'kinopoisk': 8.5},
         'The Shawshank Redemption': {'imdb': 9.3, 'kinopoisk': 9.1},
         'Avengers: Endgame': {'imdb': 8.4, 'kinopoisk': 7.7}}

average_rating = min(films, key=lambda film: sum(films[film].values()))
print(average_rating)



# Функция non_negative_even()
# Реализуйте функцию non_negative_even(),  которая принимает один аргумент:

# numbers — непустой список чисел

# Функция должна возвращать True, если все числа в списке numbers являются четными и
# неотрицательными, или False в противном случае.

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию non_negative_even(), но не код, вызывающий ее.

def non_negative_even(numbers):
    return all(num >= 0 and num % 2 == 0 for num in numbers)



# Функция is_greater()
# Реализуйте функцию is_greater(), которая принимает два аргумента в следующем порядке:

# lists — список, элементами которого являются списки целых чисел
# number — целое число

# Функция должна возвращать True, если хотя бы в одном вложенном списке из списка lists
# сумма всех элементов больше number, или False в противном случае.

# римечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию is_greater(), но не код, вызывающий ее.

def is_greater(lists, number):
    return any(sum(lst) > number for lst in lists)



# Функция custom_isinstance()
# Реализуйте функцию custom_isinstance(), которая принимает два аргумента в следующем
# порядке:

# objects — список произвольных объектов
# typeinfo — тип данных или кортеж с типами

# Функция должна возвращать единственное число — количество объектов из списка objects,
# которые принадлежат типу typeinfo или одному из типов, если был передан кортеж.

# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию custom_isinstance(), но не код, вызывающий ее.

def custom_isinstance(objects, typeinfo):
    return len(list(filter(lambda x: isinstance(x, typeinfo), objects)))



# Вам доступен список numbers. Дополните приведенный ниже код, чтобы он вывел индекс
# максимального элемента в этом списке.

# Примечание 1. Индексация начинается с нуля.

numbers = [-7724, 5023, 3197, -102, -4129, -880, 5857, -2866, -8913, 1195, 9809, 5347,
           -8071, 903, 3030, -4347, -3354, 1024, 8670, 4210, -5228, 8900, 4823, -2002,
           4900, 9520, -3658, 1104, -9554, 3064, 9632, -8701, 3384, 4370, 2034, 7822,
           -9694, 3347, 7440, -8459, 3238, -5193, -3381, 5281, 9022, 5559, 7593, -6540,
           -6204, -2483, 8729, 5810, -8254, -9846, -1801, 4882, 3838, -3140, 7609,
           -3325, 6026, 2994, -1677, 1266, -1893, -4408, -5722, -2841, 9812, 5837,
           -7474, 4624, -664, 6998, 7888, -971, 8810, 3812, -5396, 2593, 512, -4634,
           9735, -3062, 9031, -9300, 3657, 6332, 7552, 8125, -725, 4392, 1727, 8194,
           -2828, -4314, -8967, -7912, -1363, -5957]

print(numbers.index(max(numbers)))



# Функция my_pow()
# Реализуйте функцию my_pow(), которая принимает один аргумент:

# number — целое неотрицательное число

# Функция должна возвращать сумму, состоящую из цифр числа, возведенных в степень их
# порядкового номера.

# Примечание 1. Рассмотрим число 139 из первого теста. Сумма цифр этого числа,
# возведенных в степень их порядкового номера, равна:

# 1^1 + 3^2 + 9^3 = 739

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию my_pow(), но не код, вызывающий ее.

def my_pow(number):
    return sum(int(digit)**degree for degree, digit in enumerate(str(number), 1))



# Вам доступны три списка names, budgets и box_offices. Первый список содержит названия
# различных мультфильмов, второй и третий — соответствующие бюджеты и сборы в долларах.

# Дополните приведенный ниже код, чтобы он определил, какую прибыль принес каждый
# мультфильм и вывел названия мультфильмов, указав для каждого соответствующую прибыль.
# Мультфильмы должны быть расположены в лексикографическом порядке, каждый на отдельной
# строке, в следующем формате:

# <фильм>: <прибыль>$

# Примечание 1. Прибыль определяется как разность сборов и бюджета.

names = ['Moana', 'Cars', 'Zootopia', 'Ratatouille', 'Coco', 'Inside Out', 'Finding Nemo', 'Frozen']
budgets = [150000000, 120000000, 150000000, 150000000, 180000000, 175000000, 94000000, 150000000]
box_offices = [643331111, 462216280, 1023784195, 620702951, 807082196, 857611174, 940335536, 1280802282]

for name, budget, box_office in sorted(zip(names, budgets, box_offices)):
    print(f'{name}: {box_office - budget}$')



# Функция zip_longest()
# Как уже известно, функция zip() объединяет элементы различных последовательностей.
# Особенностью функции является то, что при передаче последовательностей различной
# длины элементы последовательности большей длины будут отброшены.

# Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных
# аргументов, каждый из которых является списком, и один необязательный именованный
# аргумент fill, имеющий значение по умолчанию None.

# Функция должна объединять элементы переданных последовательностей в кортежи, аналогично
# функции zip(), и возвращать в виде списка, но если последовательности имеют различную
# длину, недостающие элементы последовательностей меньшей длины должны принимать значение
# fill.

# Примечание 1. Рассмотрим первый тест со следующим вызовом:

# zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_')

# Первый список имеет длину 5, второй — 3, то есть элементам 4 и 5 из первого списка нет
# пар из второго списка. В таком случае, функция должна сопоставить им значение fill,
# равное '_'. Итак, результатом работы функции будет список:

# [(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]

# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую
# функцию zip_longest(), но не код, вызывающий ее.

def zip_longest(*args, fill=None):
    for lst in args:
        while len(lst) != len(max(args, key=len)):
            lst.append(fill)
    return [elements for elements in zip(*args)]



# Необычная сортировка 🌶️
# Дана строка, содержащая латинские буквы и цифры. Напишите программу, которая сортирует
# символы в строке согласно следующим правилам:

# все отсортированные строчные буквы стоят перед заглавными буквами
# все отсортированные заглавные буквы стоят перед цифрами
# все отсортированные нечетные цифры стоят перед четными

# Формат входных данных
# На вход программе подается строка, содержащая латинские буквы и цифры.

# Формат выходных данных
# Программа должна расположить символы в строке в соответствии с условием задачи и вывести
# полученный результат.

string = input()

lower_case = ''
upper_case = ''
odd_digits = ''
even_digits = ''

for char in string:
    if char.islower():
        lower_case += char
    elif char.isupper():
        upper_case += char
    elif char.isdigit() and int(char) % 2 != 0:
        odd_digits += char
    elif char.isdigit() and int(char) % 2 == 0:
        even_digits += char

print(''.join(sorted(lower_case) + sorted(upper_case) + sorted(odd_digits) + sorted(even_digits)))